"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RUNTIME_IMPORT = "babel-plugin-ts-optchain/lib/runtime";
function getAccessorExpressionPath(t, path, accessorExpressionPath) {
    if (!accessorExpressionPath) {
        accessorExpressionPath = [];
    }
    if (!t.isMemberExpression(path.container)) {
        var defaultValue = undefined;
        if (t.isCallExpression(path.parent)) {
            defaultValue = path.parent.arguments[0];
        }
        else {
            if (t.isMemberExpression(path.node)) {
                throw new Error("Last property accessor in ts-optchain must be a function call. " +
                    ("Add () to ." + path.node.property.name + ";"));
            }
            else {
                throw new Error("You must add at least one property accessor to oc() calls");
            }
        }
        return {
            accessorExpressionPath: accessorExpressionPath,
            endNodePath: path.parentPath,
            defaultValue: defaultValue,
        };
    }
    var prop = path.container.property;
    var expression;
    if (path.container.computed) {
        // Pass computed properties as is.
        // Ex. oc(data)[ding()]() -> ding()
        expression = prop;
    }
    else {
        // Convert static property accessors to strings
        // Ex. oc().foo() -> "foo"
        expression = t.stringLiteral(prop.name);
    }
    return getAccessorExpressionPath(t, path.parentPath, accessorExpressionPath.concat(expression));
}
function transformOptchainCall(t, path) {
    // Avoid infinite recursion on already transformed nodes
    if (path.node.arguments.length > 1) {
        return;
    }
    var _a = getAccessorExpressionPath(t, path), accessorExpressionPath = _a.accessorExpressionPath, endNodePath = _a.endNodePath, defaultValue = _a.defaultValue;
    var callArgs = [
        path.node.arguments[0],
        t.arrayExpression(accessorExpressionPath),
    ];
    if (defaultValue) {
        callArgs.push(defaultValue);
    }
    endNodePath.replaceWith(t.callExpression(path.node.callee, callArgs));
}
exports.transformOptchainCall = transformOptchainCall;
function tsOptChainPlugin(babel) {
    var t = babel.types;
    /**
     * Local name of the oc import from ts-optchain if any
     */
    var name = null;
    return {
        visitor: {
            Program: function () {
                // Reset import name state when entering a new file
                name = null;
            },
            ImportDeclaration: function (path, state) {
                var opts = state.opts || {};
                var target = opts.target || "ts-optchain";
                if (path.node.source.value !== target) {
                    return;
                }
                path.node.source.value = opts.runtime || exports.RUNTIME_IMPORT;
                for (var _i = 0, _a = path.node.specifiers; _i < _a.length; _i++) {
                    var s = _a[_i];
                    if (!t.isImportSpecifier(s)) {
                        continue;
                    }
                    if (s.imported.name === "oc") {
                        name = s.local.name;
                    }
                }
            },
            CallExpression: function (path) {
                // Disable if no ts-optchain is imported
                if (!name) {
                    return;
                }
                // Handle only the oc() calls from the ts-optchain import
                if (!t.isIdentifier(path.node.callee, { name: name })) {
                    return;
                }
                transformOptchainCall(t, path);
            },
        },
    };
}
exports.default = tsOptChainPlugin;
//# sourceMappingURL=plugin.js.map